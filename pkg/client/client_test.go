// Package client provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.11.0 DO NOT EDIT.
package client

import (
	"context"
	"net/http"
	"net/url"
	"reflect"
	"testing"

	"github.com/google/uuid"
	"github.com/samber/lo"
	"github.com/stretchr/testify/assert"
)

var (
	serverUrl = "http://127.0.0.1:8080/v1/"
)

type fields struct {
	server string
}
type args struct {
	ctx        context.Context
	accountId  string
	reqEditors []RequestEditorFn
}
type Test struct {
	name    string
	fields  fields
	args    args
	want    interface{}
	postRun func(want *interface{}, resp *GetAccountByIdResponse)
	wantErr bool
}

func TestGetAccountByIdWithResponse404(t *testing.T) {
	type fields struct {
		server string
	}
	type args struct {
		ctx        context.Context
		accountId  string
		reqEditors []RequestEditorFn
	}
	tests := []struct {
		name    string
		fields  fields
		args    args
		postRun func(resp *GetAccountByIdResponse)
		wantErr bool
	}{
		// TODO: Add test cases.
		{
			name: "404 Not Found",
			fields: fields{
				server: serverUrl,
			},
			args: args{
				ctx:       context.Background(),
				accountId: "0d209d7f-d07a-4542-947f-5885fddddae2",
			},
			postRun: func(resp *GetAccountByIdResponse) {
				if resp.StatusCode() != http.StatusNotFound {
					t.Errorf("ClientWithResponses.GetAccountByIdWithResponse() = %v, want %v", resp.StatusCode(), http.StatusNotFound)
				}
			},
			wantErr: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			c, err := NewClientWithResponses(tt.fields.server)
			if err != nil {
				t.Errorf("ClientWithResponses.GetAccountByIdWithResponse() error = %v", err)
				return
			}

			got, err := c.GetAccountByIdWithResponse(tt.args.ctx, tt.args.accountId, tt.args.reqEditors...)
			if (err != nil) != tt.wantErr {
				t.Errorf("ClientWithResponses.GetAccountByIdWithResponse() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			tt.postRun(got)
		})
	}
}

func TestUrlWithFilter(t *testing.T) {
	type args struct {
		server string
		params *GetAccountAllParams
	}

	tests := []struct {
		name    string
		args    args
		postRun func(req *http.Request)
		wantErr bool
	}{
		// TODO: Add test cases.
		{
			name: "Request except page and filters",
			args: args{
				server: serverUrl,
				params: &GetAccountAllParams{},
			},
			postRun: func(req *http.Request) {
				expected := "/v1/organisation/accounts"
				r, err := url.QueryUnescape(req.URL.RequestURI())
				if err != nil {
					t.Errorf("TestUrlWithFilter.NewGetAccountAllRequest() error = %v", err)
				}
				if !reflect.DeepEqual(r, expected) {
					t.Errorf("TestUrlWithFilter.NewGetAccountAllRequest() = %v, want %v", req.RequestURI, expected)
				}
			},
		},
		{
			name: "Request with page except filters",
			args: args{
				server: serverUrl,
				params: &GetAccountAllParams{
					Page: &PageFilter{
						Number: lo.ToPtr("10"),
						Size:   lo.ToPtr("5"),
					},
				},
			},
			postRun: func(req *http.Request) {
				expected := "/v1/organisation/accounts?page[number]=10&page[size]=5"
				r, err := url.QueryUnescape(req.URL.RequestURI())
				if err != nil {
					t.Errorf("TestUrlWithFilter.NewGetAccountAllRequest() error = %v", err)
				}
				if !reflect.DeepEqual(r, expected) {
					t.Errorf("TestUrlWithFilter.NewGetAccountAllRequest() = %v, want %v", req.RequestURI, expected)
				}
			},
		},
		{
			name: "Request with page and filters",
			args: args{
				server: serverUrl,
				params: &GetAccountAllParams{
					Page: &PageFilter{
						Number: lo.ToPtr("10"),
						Size:   lo.ToPtr("5"),
					},
					Filter: &Filters{
						AccountNumber: lo.ToPtr("efaef"),
					},
				},
			},
			postRun: func(req *http.Request) {
				expected := "page[number]=10&page[size]=5&filter[account_number]=efaef"
				v, err := url.ParseQuery(expected)
				if err != nil {
					t.Errorf("TestUrlWithFilter.NewGetAccountAllRequest() error = %v", err)
				}
				r := req.URL.Query()
				if !reflect.DeepEqual(r, v) {
					t.Errorf("TestUrlWithFilter.NewGetAccountAllRequest() = %v, want %v", r, expected)
				}
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := NewGetAccountAllRequest(tt.args.server, tt.args.params)
			if (err != nil) != tt.wantErr {
				t.Errorf("TestUrlWithFilter.NewGetAccountAllRequest() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			tt.postRun(got)

		})
	}
}



func TestCreateAccountAndDeleteAccount(t *testing.T) {
	c, err := NewClientWithResponses(serverUrl)

	if err != nil {
		t.Errorf("TestCreateAccountAndDeleteAccount.NewClientWithResponses() error = %v", err)
		return
	}

	attributes := AccountAttributes{
		BankId: "400300",
		BankIdCode: "GBDSC",
		Bic: "NWBKGB22",
		Country: "GB",
		Name: &[]string{
			"it", "is", "example",
		},
	}

	request := RequestData {
		Data: &AccountData{
		Attributes:  &attributes,
		Id: lo.ToPtr(uuid.New()),
		OrganisationId: lo.ToPtr(uuid.New()),
		Version: lo.ToPtr(int64(0)),
		Type: lo.ToPtr("accounts"),
		},
	}

	if got, err := c.CreateAccountWithResponse(context.Background(), request); err != nil {
		t.Errorf("TestCreateAccountAndDeleteAccount.CreateAccountWithResponse() error = %v", err)
		return
	} else {
		if got.StatusCode() != http.StatusCreated {
			t.Errorf("TestCreateAccountAndDeleteAccount.CreateAccountWithResponse() = %v, want %v", got.StatusCode(), http.StatusOK)
			return
		}
	}

	if got, err := c.DeleteAccountByIdAndVersionWithResponse(context.Background(), request.Data.Id.String(), &DeleteAccountByIdAndVersionParams{ Version: *request.Data.Version}); err!=nil{
		t.Errorf("TestCreateAccountAndDeleteAccount.DeleteAccountByIdAndVersionWithResponse() error = %v", err)
		return
	} else {
		if got.StatusCode() != http.StatusNoContent {
			t.Errorf("TestCreateAccountAndDeleteAccount.DeleteAccountByIdAndVersionWithResponse() = %v, want %v", got.StatusCode(), http.StatusNoContent)
			return
		}
	}
}


func TestCreateAccountAndGetAccount(t *testing.T) {
	c, err := NewClientWithResponses(serverUrl)

	if err != nil {
		t.Errorf("TestCreateAccountAndGetAccount.NewClientWithResponses() error = %v", err)
		return
	}

	attributes := AccountAttributes{
		BankId: "400300",
		BankIdCode: "GBDSC",
		Bic: "NWBKGB22",
		Country: "GB",
		Name: &[]string{
			"it", "is", "example",
		},
	}

	request := RequestData {
		Data: &AccountData{
		Attributes:  &attributes,
		Id: lo.ToPtr(uuid.New()),
		OrganisationId: lo.ToPtr(uuid.New()),
		Version: lo.ToPtr(int64(0)),
		Type: lo.ToPtr("accounts"),
		},
	}

	if got, err := c.CreateAccountWithResponse(context.Background(), request); err != nil {
		t.Errorf("TestCreateAccountAndGetAccount.CreateAccountWithResponse() error = %v", err)
		return
	} else {
		if got.StatusCode() != http.StatusCreated {
			t.Errorf("TestCreateAccountAndGetAccount.CreateAccountWithResponse() = %v, want %v", got.StatusCode(), http.StatusOK)
			return
		}
	}

	if got, err := c.GetAccountByIdWithResponse(context.Background(), request.Data.Id.String()); err != nil {
		t.Errorf("TestCreateAccountAndGetAccount.GetAccountByIdWithResponse() error = %v", err)
		return
	} else {
		assert.Equal(t, http.StatusOK, got.StatusCode(), "Should be: %v, got: %v", http.StatusOK, got.StatusCode())
		assert.Equal(t, request.Data.Id, got.JSON200.Data.Id)
		assert.Equal(t, request.Data.OrganisationId, got.JSON200.Data.OrganisationId)
		assert.Equal(t, request.Data.Version, got.JSON200.Data.Version)
		assert.Equal(t, request.Data.Type, got.JSON200.Data.Type)
		assert.Equal(t, request.Data.Attributes.BankId, got.JSON200.Data.Attributes.BankId)
		assert.Equal(t, request.Data.Attributes.BankIdCode, got.JSON200.Data.Attributes.BankIdCode)
		assert.Equal(t, request.Data.Attributes.Bic, got.JSON200.Data.Attributes.Bic)
		assert.Equal(t, request.Data.Attributes.Country, got.JSON200.Data.Attributes.Country)
		assert.Equal(t, request.Data.Attributes.Name, got.JSON200.Data.Attributes.Name)
	}

	if got, err := c.DeleteAccountByIdAndVersionWithResponse(context.Background(), request.Data.Id.String(), &DeleteAccountByIdAndVersionParams{ Version: *request.Data.Version}); err!=nil{
		t.Errorf("TestCreateAccountAndGetAccount.DeleteAccountByIdAndVersionWithResponse() error = %v", err)
		return
	} else {
		if got.StatusCode() != http.StatusNoContent {
			t.Errorf("TestCreateAccountAndGetAccount.DeleteAccountByIdAndVersionWithResponse() = %v, want %v", got.StatusCode(), http.StatusNoContent)
			return
		}
	}
}
