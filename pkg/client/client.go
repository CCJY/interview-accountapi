// Package client provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.11.0 DO NOT EDIT.
package client

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
)

// Defines values for AccountAttributesAcceptanceQualifier.
const (
	AfterNextWorkingDay AccountAttributesAcceptanceQualifier = "after_next_working_day"
	NextCalendarDay     AccountAttributesAcceptanceQualifier = "next_calendar_day"
	NextWorkingDay      AccountAttributesAcceptanceQualifier = "next_working_day"
	SameDay             AccountAttributesAcceptanceQualifier = "same_day"
	SomeOtherTime       AccountAttributesAcceptanceQualifier = "some_other_time"
)

// Defines values for AccountAttributesAccountClassification.
const (
	Business AccountAttributesAccountClassification = "Business"
	Personal AccountAttributesAccountClassification = "Personal"
)

// Defines values for AccountAttributesBaseCurrency.
const (
	GBP AccountAttributesBaseCurrency = "GBP"
)

// Defines values for AccountAttributesNameMatchingStatus.
const (
	NotSupported AccountAttributesNameMatchingStatus = "not_supported"
	OptedOut     AccountAttributesNameMatchingStatus = "opted_out"
	Supported    AccountAttributesNameMatchingStatus = "supported"
	Switched     AccountAttributesNameMatchingStatus = "switched"
)

// Defines values for AccountAttributesStatus.
const (
	AccountAttributesStatusClosed    AccountAttributesStatus = "closed"
	AccountAttributesStatusConfirmed AccountAttributesStatus = "confirmed"
	AccountAttributesStatusPending   AccountAttributesStatus = "pending"
)

// Defines values for AccountAttributesStatusReason.
const (
	AccountAttributesStatusReasonBeneficiarySensitivities AccountAttributesStatusReason = "beneficiary_sensitivities"
	AccountAttributesStatusReasonBusinessReasons          AccountAttributesStatusReason = "business_reasons"
	AccountAttributesStatusReasonClosed                   AccountAttributesStatusReason = "closed"
	AccountAttributesStatusReasonCurrency                 AccountAttributesStatusReason = "currency"
	AccountAttributesStatusReasonDeceased                 AccountAttributesStatusReason = "deceased"
	AccountAttributesStatusReasonStopped                  AccountAttributesStatusReason = "stopped"
	AccountAttributesStatusReasonTermsAndConditions       AccountAttributesStatusReason = "terms_and_conditions"
	AccountAttributesStatusReasonTransferred              AccountAttributesStatusReason = "transferred"
)

// Defines values for AccountAttributesValidationType.
const (
	Card AccountAttributesValidationType = "card"
)

// AccountAttributes defines model for AccountAttributes.
type AccountAttributes struct {
	// Determines the qualifier code with which payments to the account are accepted. If not provided, payments are accepted by default with 0000 (accepted without qualification).
	AcceptanceQualifier *AccountAttributesAcceptanceQualifier `json:"acceptance_qualifier,omitempty"`

	// Classification of account, can be either Personal or Business. Defaults to Personal if not provided. Only used for Confirmation of Payee.
	AccountClassification *AccountAttributesAccountClassification `json:"account_classification,omitempty"`

	// A unique account number will be generated automatically if not provided. If provided, the account number is validated to ensure there's no duplicate. It does not undergo an MOD check.
	AccountNumber *string `json:"account_number,omitempty"`

	// Alternative primary account names, up to 3 alternative account names with one name in each line of the array. Only used for Confirmation of Payee.
	AlternativeNames *[]string `json:"alternative_names,omitempty"`

	// Local country bank identifier, must be a UK sort code.
	BankId string `json:"bank_id"`

	// Identifies the type of bank ID being used, must be GBDSC.
	BankIdCode string `json:"bank_id_code"`

	// ISO 4217 code  used to identify the base currency of the account. Must be GBP.
	BaseCurrency *AccountAttributesBaseCurrency `json:"base_currency,omitempty"`

	// SWIFT BIC in either 8 or 11 character format.
	Bic string `json:"bic"`

	// ISO 3166-1 code  used to identify the domicile of the account. Must be GB
	Country string `json:"country"`

	// A free-format reference that can be used to link this account to an external system.
	CustomerId *string `json:"customer_id,omitempty"`

	// IBAN of the account. Generated if not provided.
	Iban *string `json:"iban,omitempty"`

	// Flag to indicate if the account is a joint account, set to true if this is a joint account. Defaults to false if not provided. Only used for Confirmation of Payee.
	JointAccount *bool `json:"joint_account,omitempty"`

	// Name of the account holder, up to four lines possible.
	//
	// For Confirmation of Payee, the following rules apply:
	// * Must be the primary account name.
	// * For concatenated personal names, joint account names and organisation names, use the first line.
	// * If first and last names of a personal name are separated, use the first line for first names, the second line for last names.
	// * Titles are ignored and should not be entered."
	Name *[]string `json:"name,omitempty"`

	// Describes the status of the account for name matching via Confirmation of Payee. The value determines the code with which Form3 responds to matched Confirmation of Payee requests to this account.
	NameMatchingStatus *AccountAttributesNameMatchingStatus `json:"name_matching_status,omitempty"`

	// Mask to use when validating the reference field of inbound payments to the account. Payments without matching reference fields will be rejected.
	//
	// Matching rules:
	// * ? matches any character.
	// * # matches any character.
	// * $ matches any character.
	// * All other characters are literals. \ can be used to escape control characters to literals.
	// * Maximum length 35 characters.
	// * - and space characters are ignored in the reference when matching.
	ReferenceMask *string `json:"reference_mask,omitempty"`

	// Additional information to identify the account and account holder, 140 characters max. Can be any type of additional identification, e.g. a building society roll number. Only used for Confirmation of Payee.
	SecondaryIdentification *string `json:"secondary_identification,omitempty"`

	// Status of the account. pending and confirmed are set by Form3, closed can be set manually.
	Status *AccountAttributesStatus `json:"status,omitempty"`

	// Additional account status information, required when updating status to closed, can't be used otherwise. The FPS code with which inbound payments to the account will be rejected depends on the value of this field.
	StatusReason *AccountAttributesStatusReason `json:"status_reason,omitempty"`

	// All-purpose field for storing data related to the account.
	// If provided, this array will be copied into each Payment Admission resource relationship where this account is the beneficiary.
	UserDefinedData *string `json:"user_defined_data,omitempty"`

	// Determines if modcheck validations are carried out on inbound payments to the account. Only card is allowed if provided.
	ValidationType *AccountAttributesValidationType `json:"validation_type,omitempty"`
}

// Determines the qualifier code with which payments to the account are accepted. If not provided, payments are accepted by default with 0000 (accepted without qualification).
type AccountAttributesAcceptanceQualifier string

// Classification of account, can be either Personal or Business. Defaults to Personal if not provided. Only used for Confirmation of Payee.
type AccountAttributesAccountClassification string

// ISO 4217 code  used to identify the base currency of the account. Must be GBP.
type AccountAttributesBaseCurrency string

// Describes the status of the account for name matching via Confirmation of Payee. The value determines the code with which Form3 responds to matched Confirmation of Payee requests to this account.
type AccountAttributesNameMatchingStatus string

// Status of the account. pending and confirmed are set by Form3, closed can be set manually.
type AccountAttributesStatus string

// Additional account status information, required when updating status to closed, can't be used otherwise. The FPS code with which inbound payments to the account will be rejected depends on the value of this field.
type AccountAttributesStatusReason string

// Determines if modcheck validations are carried out on inbound payments to the account. Only card is allowed if provided.
type AccountAttributesValidationType string

// AccountData defines model for AccountData.
type AccountData struct {
	Attributes *AccountAttributes `json:"attributes,omitempty"`

	// Unique account id of the account
	Id *openapi_types.UUID `json:"id,omitempty"`

	// Unique organisation id of the account
	OrganisationId *openapi_types.UUID `json:"organisation_id,omitempty"`
	Relationships  *Relationships      `json:"relationships,omitempty"`

	// type of the account
	Type *string `json:"type,omitempty"`

	// version of the account
	Version *int64 `json:"version,omitempty"`
}

// The Account Event resources related to this account. 2 Account Event resource are created when the Account resource is created.
type AccountEvents struct {
	Data *[]AccountEventsData `json:"data,omitempty"`
}

// AccountEventsData defines model for AccountEventsData.
type AccountEventsData struct {
	// ID of the Account Event resource.
	Id *string `json:"id,omitempty"`

	// The type of resource. Always 'account_events'.
	Type *string `json:"type,omitempty"`
}

// Filters defines model for Filters.
type Filters struct {
	AccountNumber *string `json:"account_number,omitempty"`
	BankId        *string `json:"bank_id,omitempty"`
	BankIdCode    *string `json:"bank_id_code,omitempty"`
	Country       *string `json:"country,omitempty"`
	CustomerId    *string `json:"customer_id,omitempty"`
	Iban          *string `json:"iban,omitempty"`
}

// PageFilter defines model for PageFilter.
type PageFilter struct {
	// Page number being requested, defaults to 0.
	Number *int `json:"number,omitempty"`

	// Size of the page being requested, defaults to 100.
	Size *int `json:"size,omitempty"`
}

// Relationships defines model for Relationships.
type Relationships struct {
	// The Account Event resources related to this account. 2 Account Event resource are created when the Account resource is created.
	AccountEvents *AccountEvents `json:"account_events,omitempty"`
}

// RequestData defines model for RequestData.
type RequestData struct {
	Data *AccountData `json:"data,omitempty"`
}

// ResponseData defines model for ResponseData.
type ResponseData struct {
	Data *AccountData `json:"data,omitempty"`
}

// ResponseDataArray defines model for ResponseDataArray.
type ResponseDataArray = []AccountData

// GetAccountAllParams defines parameters for GetAccountAll.
type GetAccountAllParams struct {
	// Options for filtering the results
	Filter *Filters `json:"filter,omitempty"`

	// Options for filtering the results
	Page *PageFilter `json:"page,omitempty"`
}

// CreateAccountJSONBody defines parameters for CreateAccount.
type CreateAccountJSONBody = RequestData

// DeleteAccountByIdAndVersionParams defines parameters for DeleteAccountByIdAndVersion.
type DeleteAccountByIdAndVersionParams struct {
	// Current version number of the Account resource.
	Version int64 `form:"version" json:"version"`
}

// CreateAccountJSONRequestBody defines body for CreateAccount for application/json ContentType.
type CreateAccountJSONRequestBody = CreateAccountJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAccountAll request
	GetAccountAll(ctx context.Context, params *GetAccountAllParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAccount request with any body
	CreateAccountWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAccount(ctx context.Context, body CreateAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAccountByIdAndVersion request
	DeleteAccountByIdAndVersion(ctx context.Context, accountId string, params *DeleteAccountByIdAndVersionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAccountById request
	GetAccountById(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAccountAll(ctx context.Context, params *GetAccountAllParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccountAllRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAccountWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAccountRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAccount(ctx context.Context, body CreateAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAccountRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAccountByIdAndVersion(ctx context.Context, accountId string, params *DeleteAccountByIdAndVersionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAccountByIdAndVersionRequest(c.Server, accountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAccountById(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccountByIdRequest(c.Server, accountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAccountAllRequest generates requests for GetAccountAll
func NewGetAccountAllRequest(server string, params *GetAccountAllParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organisation/accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Filter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAccountRequest calls the generic CreateAccount builder with application/json body
func NewCreateAccountRequest(server string, body CreateAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAccountRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAccountRequestWithBody generates requests for CreateAccount with any type of body
func NewCreateAccountRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organisation/accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAccountByIdAndVersionRequest generates requests for DeleteAccountByIdAndVersion
func NewDeleteAccountByIdAndVersionRequest(server string, accountId string, params *DeleteAccountByIdAndVersionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_id", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organisation/accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, params.Version); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAccountByIdRequest generates requests for GetAccountById
func NewGetAccountByIdRequest(server string, accountId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_id", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organisation/accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAccountAll request
	GetAccountAllWithResponse(ctx context.Context, params *GetAccountAllParams, reqEditors ...RequestEditorFn) (*GetAccountAllResponse, error)

	// CreateAccount request with any body
	CreateAccountWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAccountResponse, error)

	CreateAccountWithResponse(ctx context.Context, body CreateAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAccountResponse, error)

	// DeleteAccountByIdAndVersion request
	DeleteAccountByIdAndVersionWithResponse(ctx context.Context, accountId string, params *DeleteAccountByIdAndVersionParams, reqEditors ...RequestEditorFn) (*DeleteAccountByIdAndVersionResponse, error)

	// GetAccountById request
	GetAccountByIdWithResponse(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*GetAccountByIdResponse, error)
}

type GetAccountAllResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseDataArray
}

// Status returns HTTPResponse.Status
func (r GetAccountAllResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccountAllResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseData
}

// Status returns HTTPResponse.Status
func (r CreateAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAccountByIdAndVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteAccountByIdAndVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAccountByIdAndVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAccountByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseData
}

// Status returns HTTPResponse.Status
func (r GetAccountByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccountByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAccountAllWithResponse request returning *GetAccountAllResponse
func (c *ClientWithResponses) GetAccountAllWithResponse(ctx context.Context, params *GetAccountAllParams, reqEditors ...RequestEditorFn) (*GetAccountAllResponse, error) {
	rsp, err := c.GetAccountAll(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAccountAllResponse(rsp)
}

// CreateAccountWithBodyWithResponse request with arbitrary body returning *CreateAccountResponse
func (c *ClientWithResponses) CreateAccountWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAccountResponse, error) {
	rsp, err := c.CreateAccountWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAccountResponse(rsp)
}

func (c *ClientWithResponses) CreateAccountWithResponse(ctx context.Context, body CreateAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAccountResponse, error) {
	rsp, err := c.CreateAccount(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAccountResponse(rsp)
}

// DeleteAccountByIdAndVersionWithResponse request returning *DeleteAccountByIdAndVersionResponse
func (c *ClientWithResponses) DeleteAccountByIdAndVersionWithResponse(ctx context.Context, accountId string, params *DeleteAccountByIdAndVersionParams, reqEditors ...RequestEditorFn) (*DeleteAccountByIdAndVersionResponse, error) {
	rsp, err := c.DeleteAccountByIdAndVersion(ctx, accountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAccountByIdAndVersionResponse(rsp)
}

// GetAccountByIdWithResponse request returning *GetAccountByIdResponse
func (c *ClientWithResponses) GetAccountByIdWithResponse(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*GetAccountByIdResponse, error) {
	rsp, err := c.GetAccountById(ctx, accountId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAccountByIdResponse(rsp)
}

// ParseGetAccountAllResponse parses an HTTP response from a GetAccountAllWithResponse call
func ParseGetAccountAllResponse(rsp *http.Response) (*GetAccountAllResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAccountAllResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseDataArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateAccountResponse parses an HTTP response from a CreateAccountWithResponse call
func ParseCreateAccountResponse(rsp *http.Response) (*CreateAccountResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteAccountByIdAndVersionResponse parses an HTTP response from a DeleteAccountByIdAndVersionWithResponse call
func ParseDeleteAccountByIdAndVersionResponse(rsp *http.Response) (*DeleteAccountByIdAndVersionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAccountByIdAndVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAccountByIdResponse parses an HTTP response from a GetAccountByIdWithResponse call
func ParseGetAccountByIdResponse(rsp *http.Response) (*GetAccountByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAccountByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
